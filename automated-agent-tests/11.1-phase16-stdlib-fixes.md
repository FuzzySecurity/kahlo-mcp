# Phase 11.1 - Phase 16 Stdlib Bug Fixes

**Objective**: Validate four critical bug fixes in `jobScriptStdlib.js` delivered in Phase 16. These fixes address argument passing in `hook.method()`, class loader preservation in `hook.onClassLoad()`, surrogate pair handling in `strings.toUtf8()`, and unpadded input handling in `bytes.fromBase64()`. Each test targets one specific regression to confirm the fix works correctly.

**Status**: COMPLETE (Executed: 2026-01-24)

**Device ID**: `2C161FDH200CY0`
**Package**: `jp.naver.line.android`

---

## Background

Phase 16 shipped fixes for several stdlib bugs discovered during real-world instrumentation work. Four of these bugs had observable, testable symptoms that can be validated through targeted Kahlo jobs:

| Issue | Namespace | Bug | Root Cause |
|-------|-----------|-----|------------|
| 16.1 | `hook` | `hook.method()` multi-parameter methods receive wrong arguments | `.call(this, args)` instead of `.apply(this, args)` |
| 16.4 | `hook` | `hook.onClassLoad()` corrupts class resolution | `Java.classFactory.loader` not restored after iteration |
| 16.14 | `strings` | `strings.toUtf8()` produces invalid bytes for emoji | `charCodeAt()` returns UTF-16 code units; surrogate pairs not handled |
| 16.23 | `bytes` | `bytes.fromBase64()` fails on unpadded input | `outputLen` computed as non-integer for input length not divisible by 4 |

---

## Setup

### Attach to Target Process

Before running any tests, attach to the LINE application (or any running Java app) in attach mode. Tests in this phase do not require spawn-gated bootstraps since they validate stdlib utility functions, not early initialization hooks.

**Command**:
```javascript
kahlo_targets_ensure(
  device_id="2C161FDH200CY0",
  package="jp.naver.line.android",
  mode="attach"
)
```

**Expected Result**:
```json
{
  "ok": true,
  "data": {
    "target_id": "tgt_<uuid>"
  }
}
```

**Key Assertions**:
- `ok` is `true` -- attached to running process
- `target_id` returned -- ready to accept jobs

Record the `target_id` for use in all subsequent tests.

**Actual Execution**:
- Target ID: `tgt_3069541e-af8b-4d22-8d0e-52f48e48aed2`
- PID: 18728
- Package: LINE (jp.naver.line.android)
- Agent State: ready

### Verify Target Status

**Command**:
```javascript
kahlo_targets_status(target_id="tgt_<uuid>")
```

**Expected Result**:
```json
{
  "ok": true,
  "data": {
    "target": {
      "target_id": "tgt_<uuid>",
      "device_id": "2C161FDH200CY0",
      "package": "jp.naver.line.android",
      "pid": "<pid>",
      "mode": "attach",
      "state": "running",
      "agent_state": "ready"
    }
  }
}
```

**Key Assertions**:
- `state`: `"running"`
- `agent_state`: `"ready"` (orchestrator injected, stdlib available)

---

## Test 11.1.1 - hook.method() Multi-Parameter Argument Passing (Issue 16.1)

### Objective

Verify that `ctx.stdlib.hook.method()` correctly spreads arguments to `onEnter` callbacks when hooking Java methods with multiple parameters. Before the fix, `.call(this, args)` passed the entire args array as a single argument instead of using `.apply(this, args)` to spread them. This broke every hooked method with more than one parameter.

### What Was Fixed

In `jobScriptStdlib.js`, the hook wrapper used:
```javascript
originalImplementation.call(this, args);  // BUG: passes [arg0, arg1] as one argument
```
The fix changed it to:
```javascript
originalImplementation.apply(this, args); // FIX: spreads [arg0, arg1] as two arguments
```

### Job Source

**Command**:
```javascript
kahlo_jobs_start(
  target_id="tgt_<uuid>",
  type="oneshot",
  module={
    kind: "source",
    source: `
module.exports = {
  start: function(params, ctx) {
    Java.perform(function() {
      var capturedArgs = [];

      // Hook Log.d(String tag, String msg) -- a 2-parameter method
      ctx.stdlib.hook.method('android.util.Log', 'd', {
        paramTypes: ['java.lang.String', 'java.lang.String'],
        onEnter: function(args) {
          var tag = ctx.stdlib.strings.fromJava(args[0]);
          var msg = ctx.stdlib.strings.fromJava(args[1]);
          if (tag === 'kahlo_test_16_1') {
            capturedArgs.push({tag: tag, msg: msg});
            ctx.emit('hook.args.captured', {
              tag: tag,
              msg: msg,
              arg0_type: typeof args[0],
              arg1_type: typeof args[1],
              args_length: args.length
            }, 'info');
          }
        }
      });

      // Trigger the hook by calling Log.d from within Java context
      var Log = Java.use('android.util.Log');
      Log.d('kahlo_test_16_1', 'multi_param_test');

      ctx.emit('test.complete', {
        test: '11.1.1',
        captured_count: capturedArgs.length,
        args_correct: capturedArgs.length > 0
          && capturedArgs[0].tag === 'kahlo_test_16_1'
          && capturedArgs[0].msg === 'multi_param_test'
      }, 'info');
    });
  }
};
`
  }
)
```

### Expected Events

**Fetch Command**:
```javascript
kahlo_events_fetch(target_id="tgt_<uuid>", limit=10)
```

**Expected Events** (in order):
1. `job.started` -- Job began execution
2. `hook.args.captured` -- onEnter callback fired with individual arguments:
   ```json
   {
     "tag": "kahlo_test_16_1",
     "msg": "multi_param_test",
     "arg0_type": "object",
     "arg1_type": "object",
     "args_length": 2
   }
   ```
3. `test.complete` -- Test self-assessment:
   ```json
   {
     "test": "11.1.1",
     "captured_count": 1,
     "args_correct": true
   }
   ```
4. `job.completed` -- Job finished

### Validation Checklist

- [x] Job completes without errors
- [x] `hook.args.captured` event is present
- [x] `tag === "kahlo_test_16_1"` (arg0 is the tag string, not an array)
- [x] `msg === "multi_param_test"` (arg1 is the message string, not undefined)
- [x] `args_length === 2` (two separate arguments, not 1 array-as-argument)
- [x] `arg0_type` and `arg1_type` are both `"string"` (converted from Java), not `"undefined"`
- [x] `test.complete` event shows `args_correct === true`

**Actual Results**:
- Job ID: `job_54f19d44-0d53-482a-a295-b966b2067e12`
- Status: completed
- Events captured:
  ```json
  {
    "tag": "kahlo_test_16_1",
    "msg": "multi_param_test",
    "arg0_type": "string",
    "arg1_type": "string",
    "args_length": 2
  }
  ```
- Test self-assessment: `args_correct: true`
- **PASS**: All assertions verified

### Pre-Fix Behavior

Before the fix, `args` in the `onEnter` callback would have been:
- `args[0]` = the entire original args array `[JavaString("kahlo_test_16_1"), JavaString("multi_param_test")]`
- `args[1]` = `undefined`
- `args.length` = `1` (or the array would appear as a single nested element)

This would cause `args_length` to be 1, `arg1_type` to be `"undefined"`, and `msg` to be null or throw.

---

## Test 11.1.2 - hook.onClassLoad() ClassLoader Preservation (Issue 16.4)

**Actual Results**:
- Job ID: `job_357ec22b-cc16-45a7-ab67-e1bde87c836a`
- Status: completed
- Events captured:
  ```json
  {
    "test": "11.1.2",
    "loader_preserved": true,
    "loader_before_null": false,
    "loader_after_null": false,
    "java_use_works": true,
    "timestamp": 1770347733468
  }
  ```
- **PASS**: All assertions verified

### Objective

Verify that `ctx.stdlib.hook.onClassLoad()` restores `Java.classFactory.loader` to its original value after iterating class loaders. Before the fix, the function set `Java.classFactory.loader = loader` inside its enumeration loop but never restored it, corrupting class resolution for the rest of the script.

### What Was Fixed

In `jobScriptStdlib.js`, the `onClassLoad()` implementation iterated through class loaders:
```javascript
// BUG: loader left set to last enumerated value
Java.classFactory.loader = loader;
// ... check if class is loadable ...
// never restored
```
The fix saves and restores the original loader:
```javascript
var savedLoader = Java.classFactory.loader;
Java.classFactory.loader = loader;
// ... check if class is loadable ...
Java.classFactory.loader = savedLoader; // FIX: restore original
```

### Job Source

**Command**:
```javascript
kahlo_jobs_start(
  target_id="tgt_<uuid>",
  type="oneshot",
  module={
    kind: "source",
    source: `
module.exports = {
  start: function(params, ctx) {
    Java.perform(function() {
      // Record the default class loader before calling onClassLoad
      var loaderBefore = Java.classFactory.loader;

      // Register onClassLoad callback for a class that is already loaded.
      // This exercises the loader iteration path even though the callback
      // may fire immediately (class is present).
      ctx.stdlib.hook.onClassLoad('android.app.Activity', function(klass) {
        ctx.emit('class.loaded', {
          name: 'android.app.Activity'
        }, 'info');
      });

      // Check if Java.classFactory.loader was restored
      var loaderAfter = Java.classFactory.loader;
      var loaderPreserved = (loaderBefore === loaderAfter);

      // Verify that Java.use still works with the default class loader.
      // If the loader was corrupted, this could fail with ClassNotFoundException
      // for standard framework classes.
      var javaUseResult = ctx.stdlib.safe.call(function() {
        var System = Java.use('java.lang.System');
        return System.currentTimeMillis();
      });

      ctx.emit('loader.test', {
        test: '11.1.2',
        loader_preserved: loaderPreserved,
        loader_before_null: (loaderBefore === null),
        loader_after_null: (loaderAfter === null),
        java_use_works: javaUseResult.ok,
        timestamp: javaUseResult.ok ? Number(javaUseResult.result) : null
      }, 'info');
    });
  }
};
`
  }
)
```

### Expected Events

**Fetch Command**:
```javascript
kahlo_events_fetch(target_id="tgt_<uuid>", limit=10)
```

**Expected Events** (in order):
1. `job.started` -- Job began execution
2. `class.loaded` (optional) -- If the class was found during loader enumeration:
   ```json
   {
     "name": "android.app.Activity"
   }
   ```
3. `loader.test` -- Loader preservation results:
   ```json
   {
     "test": "11.1.2",
     "loader_preserved": true,
     "loader_before_null": true,
     "loader_after_null": true,
     "java_use_works": true,
     "timestamp": 1738750000000
   }
   ```
4. `job.completed` -- Job finished

### Validation Checklist

- [x] Job completes without errors
- [x] `loader.test` event is present
- [x] `loader_preserved === true` (classFactory.loader restored to its original value)
- [x] `java_use_works === true` (Java.use resolves standard classes after onClassLoad)
- [x] `timestamp` is a valid epoch millisecond value (not null)

### Pre-Fix Behavior

Before the fix, `Java.classFactory.loader` would remain set to the last enumerated class loader from the `Java.enumerateClassLoaders()` iteration. This could cause:
- `loader_preserved === false` (loader changed)
- `java_use_works === false` (Java.use fails with wrong class loader context)
- Subsequent `Java.use()` calls throughout the script could throw `ClassNotFoundException` for classes not visible to that particular loader

---

## Test 11.1.3 - strings.toUtf8() Surrogate Pair Handling (Issue 16.14)

**Actual Results**:
- Job ID: `job_082b94c8-d106-4cfe-a544-62973df7e9e8`
- Status: completed
- Events captured:
  - Emoji test: `emoji_hex: "f09f9880"`, `byte_count: 4`, `emoji_correct: true`
  - Mixed test: `mixed_hex: "4869f09f988021"`, `byte_count: 7`, `mixed_correct: true`
  - ASCII test: `ascii_hex: "48656c6c6f"`, `byte_count: 5`, `ascii_correct: true`
  - Overall: `all_correct: true`
- **PASS**: All assertions verified

### Objective

Verify that `ctx.stdlib.strings.toUtf8()` correctly encodes emoji and other characters above U+FFFF (supplementary plane) as valid 4-byte UTF-8 sequences. Before the fix, the fallback encoder used `charCodeAt()` which returns UTF-16 code units, causing surrogate pairs to be encoded as two invalid 3-byte sequences (CESU-8) instead of one valid 4-byte sequence.

### What Was Fixed

In `jobScriptStdlib.js`, the UTF-8 encoder used:
```javascript
// BUG: charCodeAt returns UTF-16 code units (0xD800-0xDFFF for surrogates)
var c = str.charCodeAt(i);
// Each surrogate encoded as 3 bytes -> 6 bytes total for one emoji (invalid UTF-8)
```
The fix uses:
```javascript
// FIX: codePointAt returns actual Unicode code points (e.g., 0x1F600 for emoji)
var c = str.codePointAt(i);
if (c >= 0x10000) {
  // Encode as 4-byte UTF-8 sequence: F0 xx xx xx
  // Advance index by 2 to skip the surrogate pair
  i++;
}
```

### Job Source

**Command**:
```javascript
kahlo_jobs_start(
  target_id="tgt_<uuid>",
  type="oneshot",
  module={
    kind: "source",
    source: `
module.exports = {
  start: function(params, ctx) {
    // Test 1: Emoji encoding (U+1F600 = grinning face)
    // In JavaScript source this is the surrogate pair \\uD83D\\uDE00
    var emoji = '\\uD83D\\uDE00';
    var emojiBytes = ctx.stdlib.strings.toUtf8(emoji);
    var emojiHex = ctx.stdlib.bytes.toHex(emojiBytes);

    // Expected: F0 9F 98 80 (4-byte UTF-8 for U+1F600)
    var emojiExpected = 'f09f9880';
    var emojiCorrect = (emojiHex.toLowerCase() === emojiExpected);

    ctx.emit('utf8.emoji', {
      test: '11.1.3a',
      emoji_hex: emojiHex,
      emoji_expected: emojiExpected,
      emoji_correct: emojiCorrect,
      byte_count: emojiBytes.length
    }, 'info');

    // Test 2: Mixed ASCII + emoji + ASCII
    var mixed = 'Hi' + emoji + '!';
    var mixedBytes = ctx.stdlib.strings.toUtf8(mixed);
    var mixedHex = ctx.stdlib.bytes.toHex(mixedBytes);

    // Expected: 48(H) 69(i) F09F9880(emoji) 21(!) = "4869f09f988021"
    var mixedExpected = '4869f09f988021';
    var mixedCorrect = (mixedHex.toLowerCase() === mixedExpected);

    ctx.emit('utf8.mixed', {
      test: '11.1.3b',
      mixed_hex: mixedHex,
      mixed_expected: mixedExpected,
      mixed_correct: mixedCorrect,
      byte_count: mixedBytes.length
    }, 'info');

    // Test 3: Pure ASCII baseline (should be unaffected by fix)
    var ascii = 'Hello';
    var asciiBytes = ctx.stdlib.strings.toUtf8(ascii);
    var asciiHex = ctx.stdlib.bytes.toHex(asciiBytes);
    var asciiExpected = '48656c6c6f';
    var asciiCorrect = (asciiHex.toLowerCase() === asciiExpected);

    ctx.emit('utf8.ascii', {
      test: '11.1.3c',
      ascii_hex: asciiHex,
      ascii_expected: asciiExpected,
      ascii_correct: asciiCorrect,
      byte_count: asciiBytes.length
    }, 'info');

    ctx.emit('test.complete', {
      test: '11.1.3',
      all_correct: emojiCorrect && mixedCorrect && asciiCorrect
    }, 'info');
  }
};
`
  }
)
```

### Expected Events

**Fetch Command**:
```javascript
kahlo_events_fetch(target_id="tgt_<uuid>", limit=10)
```

**Expected Events** (in order):
1. `job.started` -- Job began execution
2. `utf8.emoji` -- Emoji encoding result:
   ```json
   {
     "test": "11.1.3a",
     "emoji_hex": "f09f9880",
     "emoji_expected": "f09f9880",
     "emoji_correct": true,
     "byte_count": 4
   }
   ```
3. `utf8.mixed` -- Mixed string encoding result:
   ```json
   {
     "test": "11.1.3b",
     "mixed_hex": "4869f09f988021",
     "mixed_expected": "4869f09f988021",
     "mixed_correct": true,
     "byte_count": 7
   }
   ```
4. `utf8.ascii` -- ASCII baseline result:
   ```json
   {
     "test": "11.1.3c",
     "ascii_hex": "48656c6c6f",
     "ascii_expected": "48656c6c6f",
     "ascii_correct": true,
     "byte_count": 5
   }
   ```
5. `test.complete` -- Test self-assessment:
   ```json
   {
     "test": "11.1.3",
     "all_correct": true
   }
   ```
6. `job.completed` -- Job finished

### Validation Checklist

- [x] Job completes without errors
- [x] `utf8.emoji` event shows `emoji_hex === "f09f9880"` (4 bytes, valid UTF-8)
- [x] `utf8.emoji` event shows `byte_count === 4` (not 6)
- [x] `utf8.mixed` event shows `mixed_hex === "4869f09f988021"` (7 bytes total)
- [x] `utf8.ascii` event shows `ascii_correct === true` (ASCII unaffected by fix)
- [x] `test.complete` event shows `all_correct === true`

### Pre-Fix Behavior

Before the fix, `charCodeAt()` would return the individual UTF-16 surrogate code units (0xD83D and 0xDE00) instead of the combined code point (0x1F600). Each surrogate would be encoded as a 3-byte sequence:
- 0xD83D -> `ED A0 BD` (3 bytes, invalid UTF-8)
- 0xDE00 -> `ED B8 80` (3 bytes, invalid UTF-8)

This would produce:
- `emoji_hex === "eda0bdeda880"` or similar (6 bytes instead of 4)
- `byte_count === 6` (not 4)
- The output is CESU-8, not valid UTF-8, and would be rejected by strict UTF-8 parsers

---

## Test 11.1.4 - bytes.fromBase64() Unpadded Input (Issue 16.23)

**Actual Results**:
- Job ID: `job_a9ac242c-5e2b-4978-9338-0adc5d12f23f`
- Status: completed
- Events captured:
  - Padded test: `output_hex: "010203"`, `correct: true`
  - Unpadded test: `output_hex: "01020304"`, `correct: true`
  - Hello test: `output_hex: "48656c6c6f"`, `output_str: "Hello"`, `correct: true`
  - Single byte test: `output_hex: "01"`, `correct: true`
  - Overall: `padded_ok: true`, `unpadded_ok: true`, `hello_ok: true`, `single_ok: true`
- **PASS**: All assertions verified

### Objective

Verify that `ctx.stdlib.bytes.fromBase64()` correctly decodes base64 strings that lack padding characters (`=`). Before the fix, the output length was computed as a non-integer when the input length was not divisible by 4, which could produce incorrect output or throw.

### What Was Fixed

In `jobScriptStdlib.js`, the base64 decoder computed:
```javascript
// BUG: when input.length % 4 !== 0, this produces a non-integer
var outputLen = (input.length / 4) * 3;
// new Uint8Array(3.75) or similar -> undefined behavior
```
The fix applies `Math.floor()`:
```javascript
// FIX: floor the result to handle unpadded input correctly
var outputLen = Math.floor((input.length * 3) / 4);
```

### Job Source

**Command**:
```javascript
kahlo_jobs_start(
  target_id="tgt_<uuid>",
  type="oneshot",
  module={
    kind: "source",
    source: `
module.exports = {
  start: function(params, ctx) {
    // Test 1: Standard padded base64 (baseline -- should always work)
    // "AQID" decodes to [0x01, 0x02, 0x03]
    var padded = ctx.stdlib.bytes.fromBase64('AQID');
    var paddedHex = ctx.stdlib.bytes.toHex(padded);

    ctx.emit('base64.padded', {
      test: '11.1.4a',
      input: 'AQID',
      output_hex: paddedHex,
      expected_hex: '010203',
      correct: paddedHex.toLowerCase() === '010203'
    }, 'info');

    // Test 2: Unpadded base64 -- this triggered the bug
    // "AQIDBA" (no padding) decodes to [0x01, 0x02, 0x03, 0x04]
    // Properly padded form would be "AQIDBA=="
    var unpadded = ctx.stdlib.bytes.fromBase64('AQIDBA');
    var unpaddedHex = ctx.stdlib.bytes.toHex(unpadded);

    ctx.emit('base64.unpadded', {
      test: '11.1.4b',
      input: 'AQIDBA',
      output_hex: unpaddedHex,
      expected_hex: '01020304',
      correct: unpaddedHex.toLowerCase() === '01020304'
    }, 'info');

    // Test 3: Another unpadded case -- "Hello" in base64 is "SGVsbG8="
    // Without padding: "SGVsbG8"
    var unpadded2 = ctx.stdlib.bytes.fromBase64('SGVsbG8');
    var unpadded2Hex = ctx.stdlib.bytes.toHex(unpadded2);
    var unpadded2Str = ctx.stdlib.strings.fromUtf8(unpadded2);

    ctx.emit('base64.hello', {
      test: '11.1.4c',
      input: 'SGVsbG8',
      output_hex: unpadded2Hex,
      output_str: unpadded2Str,
      expected_str: 'Hello',
      correct: unpadded2Str === 'Hello'
    }, 'info');

    // Test 4: Single trailing char (requires 2 padding chars removed)
    // "AQ" (no padding) decodes to [0x01]
    // Properly padded form would be "AQ=="
    var singleByte = ctx.stdlib.bytes.fromBase64('AQ');
    var singleHex = ctx.stdlib.bytes.toHex(singleByte);

    ctx.emit('base64.single', {
      test: '11.1.4d',
      input: 'AQ',
      output_hex: singleHex,
      expected_hex: '01',
      correct: singleHex.toLowerCase() === '01'
    }, 'info');

    ctx.emit('test.complete', {
      test: '11.1.4',
      padded_ok: paddedHex.toLowerCase() === '010203',
      unpadded_ok: unpaddedHex.toLowerCase() === '01020304',
      hello_ok: unpadded2Str === 'Hello',
      single_ok: singleHex.toLowerCase() === '01'
    }, 'info');
  }
};
`
  }
)
```

### Expected Events

**Fetch Command**:
```javascript
kahlo_events_fetch(target_id="tgt_<uuid>", limit=10)
```

**Expected Events** (in order):
1. `job.started` -- Job began execution
2. `base64.padded` -- Standard padded base64 (baseline):
   ```json
   {
     "test": "11.1.4a",
     "input": "AQID",
     "output_hex": "010203",
     "expected_hex": "010203",
     "correct": true
   }
   ```
3. `base64.unpadded` -- Unpadded base64 (primary regression):
   ```json
   {
     "test": "11.1.4b",
     "input": "AQIDBA",
     "output_hex": "01020304",
     "expected_hex": "01020304",
     "correct": true
   }
   ```
4. `base64.hello` -- Unpadded "Hello" string:
   ```json
   {
     "test": "11.1.4c",
     "input": "SGVsbG8",
     "output_hex": "48656c6c6f",
     "output_str": "Hello",
     "expected_str": "Hello",
     "correct": true
   }
   ```
5. `base64.single` -- Minimal unpadded case:
   ```json
   {
     "test": "11.1.4d",
     "input": "AQ",
     "output_hex": "01",
     "expected_hex": "01",
     "correct": true
   }
   ```
6. `test.complete` -- Test self-assessment:
   ```json
   {
     "test": "11.1.4",
     "padded_ok": true,
     "unpadded_ok": true,
     "hello_ok": true,
     "single_ok": true
   }
   ```
7. `job.completed` -- Job finished

### Validation Checklist

- [x] Job completes without errors (no crash from non-integer array length)
- [x] `base64.padded` shows `correct === true` (standard padded base64 still works)
- [x] `base64.unpadded` shows `correct === true` (primary bug: unpadded 6-char input decodes correctly)
- [x] `base64.hello` shows `correct === true` ("Hello" decoded from unpadded base64)
- [x] `base64.single` shows `correct === true` (minimal unpadded case with 2 missing `=` chars)
- [x] `test.complete` shows all four sub-tests passing

### Pre-Fix Behavior

Before the fix, unpadded input would compute a non-integer output length:
- Input `"AQIDBA"` (length 6): `outputLen = (6 / 4) * 3 = 4.5`
- `new Uint8Array(4.5)` behavior is undefined -- it may truncate to 4, round to 5, or throw a `RangeError`
- Input `"AQ"` (length 2): `outputLen = (2 / 4) * 3 = 1.5`
- Decoded bytes could be truncated, corrupted, or the call could throw entirely

This is commonly encountered with JWTs and other protocols that use base64url encoding without padding.

---

## Cleanup

### Detach Target

After all four tests are complete, detach from the target process.

**Command**:
```javascript
kahlo_targets_detach(target_id="tgt_<uuid>")
```

**Expected Result**:
```json
{
  "ok": true,
  "data": {
    "target_id": "tgt_<uuid>",
    "state": "detached"
  }
}
```

---

## Validation Summary

| Test | Issue | Stdlib Function | What Was Broken | Key Assertion | Status |
|------|-------|-----------------|-----------------|---------------|--------|
| 11.1.1 | 16.1 | `hook.method()` | `.call()` instead of `.apply()` -- multi-param args collapsed into single array | `args_length === 2` and both args individually accessible | [x] PASS |
| 11.1.2 | 16.4 | `hook.onClassLoad()` | `classFactory.loader` not restored after iteration | `loader_preserved === true` and `java_use_works === true` | [x] PASS |
| 11.1.3 | 16.14 | `strings.toUtf8()` | `charCodeAt()` breaks surrogate pairs into invalid 3-byte seqs | `emoji_hex === "f09f9880"` (4 bytes, not 6) | [x] PASS |
| 11.1.4 | 16.23 | `bytes.fromBase64()` | Non-integer `outputLen` for unpadded input | Unpadded input decodes correctly without crash | [x] PASS |

### Cross-Cutting Assertions

- [x] All four jobs complete without errors or crashes
- [x] No stdlib function throws an unhandled exception
- [x] Fix for one issue does not regress another (ASCII baseline in 11.1.3, padded baseline in 11.1.4)
- [x] Target detaches cleanly after all tests

### Execution Summary

**Execution Date**: 2026-01-24
**Device**: 2C161FDH200CY0 (Pixel 7, USB)
**Target**: LINE (jp.naver.line.android)
**Target ID**: tgt_3069541e-af8b-4d22-8d0e-52f48e48aed2
**PID**: 18728

**Job Results**:
1. Test 11.1.1 (hook.method): `job_54f19d44-0d53-482a-a295-b966b2067e12` - PASS
2. Test 11.1.2 (hook.onClassLoad): `job_357ec22b-cc16-45a7-ab67-e1bde87c836a` - PASS
3. Test 11.1.3 (strings.toUtf8): `job_082b94c8-d106-4cfe-a544-62973df7e9e8` - PASS
4. Test 11.1.4 (bytes.fromBase64): `job_a9ac242c-5e2b-4978-9338-0adc5d12f23f` - PASS

**Overall Result**: ALL TESTS PASSED

All four Phase 16 stdlib bug fixes have been validated:
- Issue 16.1: Multi-parameter argument passing in hook.method() works correctly
- Issue 16.4: ClassLoader preservation in hook.onClassLoad() works correctly
- Issue 16.14: Surrogate pair handling in strings.toUtf8() produces valid UTF-8
- Issue 16.23: Unpadded base64 input decodes correctly without crashes

---

## Relationship to Other Phases

- **Phase 8.4-8.6** (stdlib bytes/strings): Tests 11.1.3 and 11.1.4 extend the original validation of `strings.toUtf8()` and `bytes.fromBase64()` with edge cases that were not covered
- **Phase 8.7-8.9** (stdlib hook/safe/time): Tests 11.1.1 and 11.1.2 extend the original `hook.method()` and `hook.onClassLoad()` validation with multi-parameter and class-loader-corruption scenarios
- **Phase 16** (stdlib bug fixes): This test file validates the fixes shipped in Phase 16; all four tests should fail on pre-Phase-16 builds and pass on post-Phase-16 builds

---

**End of Phase 11.1**

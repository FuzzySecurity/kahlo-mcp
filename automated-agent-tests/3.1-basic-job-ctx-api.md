# Phase 3.1 - Basic Job (ctx API Testing)

**Target ID**: `tgt_7a20e4fc-12f7-42c2-8e4d-4569053eeff6`
**Job ID**: `job_58f8635f-247e-4a74-a427-002ae1cc15b5`
**Execution Date**: 2026-01-21T06:08:19Z
**Status**: COMPLETE ✓

---

## Objective

Validate the basic job lifecycle and ctx API functionality:
- Verify `init()` is called before `start()`
- Test `ctx.job_id` availability and format
- Test `ctx.javaAvailable()` function
- Test `ctx.requireJava()` function
- Verify parameter passing through `params` object
- Verify oneshot job return value capture

---

## Test Job Code

```javascript
module.exports = {
  init: function(ctx) {
    ctx.emit('init.called', {job_id: ctx.job_id}, 'debug');
  },

  start: function(params, ctx) {
    // Test ctx.job_id
    ctx.emit('ctx.job_id', {value: ctx.job_id}, 'info');

    // Test ctx.Java and ctx.javaAvailable
    ctx.emit('ctx.javaAvailable', {value: ctx.javaAvailable()}, 'info');

    // Test ctx.requireJava
    var Java = ctx.requireJava('Testing requireJava');
    ctx.emit('ctx.requireJava', {success: Java !== null}, 'info');

    // Test params passing
    ctx.emit('params.received', {params: params}, 'info');

    // Return result for oneshot
    return {
      job_id: ctx.job_id,
      java_available: ctx.javaAvailable(),
      params_echo: params
    };
  }
};
```

**Parameters Passed**:
```json
{
  "test_param": "hello",
  "number": 42,
  "nested": {
    "a": 1
  }
}
```

**Job Type**: `oneshot`

---

## Execution Results

### Job Status
```json
{
  "job_id": "job_58f8635f-247e-4a74-a427-002ae1cc15b5",
  "target_id": "tgt_7a20e4fc-12f7-42c2-8e4d-4569053eeff6",
  "type": "oneshot",
  "state": "completed",
  "health": "unknown",
  "created_at": "2026-01-21T06:08:19.072Z",
  "updated_at": "2026-01-21T06:08:19.337Z"
}
```

**Execution Time**: 265ms (from created_at to updated_at)

---

## Events Captured

### Event 1: job.started
```json
{
  "event_id": "3ccae3f1-9e08-4bd7-b7c2-dd2081f434b1",
  "ts": "2026-01-21T06:08:20.654Z",
  "kind": "job.started",
  "level": "info",
  "payload": {
    "job_id": "job_58f8635f-247e-4a74-a427-002ae1cc15b5",
    "type": "oneshot"
  }
}
```

### Event 2: init.called
```json
{
  "event_id": "43faada0-a032-4ab4-a5a7-d9f2aac86bd2",
  "ts": "2026-01-21T06:08:20.654Z",
  "kind": "init.called",
  "level": "debug",
  "payload": {
    "job_id": "job_58f8635f-247e-4a74-a427-002ae1cc15b5"
  }
}
```

**Analysis**: `init()` was called and had access to `ctx.job_id` as expected.

### Event 3: ctx.job_id
```json
{
  "event_id": "886db328-81a4-485d-90dc-214751767d79",
  "ts": "2026-01-21T06:08:20.654Z",
  "kind": "ctx.job_id",
  "level": "info",
  "payload": {
    "value": "job_58f8635f-247e-4a74-a427-002ae1cc15b5"
  }
}
```

**Analysis**: `ctx.job_id` is available in `start()` and matches the expected job ID format (UUID).

### Event 4: ctx.javaAvailable
```json
{
  "event_id": "2bc4c661-b2db-4242-8674-0f52b10ab784",
  "ts": "2026-01-21T06:08:20.654Z",
  "kind": "ctx.javaAvailable",
  "level": "info",
  "payload": {
    "value": true
  }
}
```

**Analysis**: `ctx.javaAvailable()` returned `true`, confirming Java runtime is accessible in the target process (LINE app).

### Event 5: ctx.requireJava
```json
{
  "event_id": "982deac3-cb90-4f07-85b0-27eb82c55d65",
  "ts": "2026-01-21T06:08:20.654Z",
  "kind": "ctx.requireJava",
  "level": "info",
  "payload": {
    "success": true
  }
}
```

**Analysis**: `ctx.requireJava()` successfully returned the Java bridge object (not null).

### Event 6: params.received
```json
{
  "event_id": "2c7ca3a9-59f1-4c44-96ae-8b75ed5e5428",
  "ts": "2026-01-21T06:08:20.654Z",
  "kind": "params.received",
  "level": "info",
  "payload": {
    "params": {
      "test_param": "hello",
      "number": 42,
      "nested": {
        "a": 1
      }
    }
  }
}
```

**Analysis**: All parameters were correctly passed through and accessible in the `start()` function:
- String parameter: `"hello"`
- Number parameter: `42`
- Nested object: `{a: 1}`

### Event 7: job.completed
```json
{
  "event_id": "1bb991aa-ce1b-4d8f-859d-70c41b81ee7f",
  "ts": "2026-01-21T06:08:20.654Z",
  "kind": "job.completed",
  "level": "info",
  "payload": {
    "result": {
      "job_id": "job_58f8635f-247e-4a74-a427-002ae1cc15b5",
      "java_available": true,
      "params_echo": {
        "test_param": "hello",
        "number": 42,
        "nested": {
          "a": 1
        }
      }
    }
  }
}
```

**Analysis**: The return value from `start()` was captured in the `job.completed` event's result payload. All returned data is intact:
- Job ID echoed back correctly
- Java availability status confirmed
- All parameters echoed back with correct types and values

---

## Validation Results

| Test Case | Status | Evidence |
|-----------|--------|----------|
| **init() called before start()** | ✓ PASS | Event 2 (`init.called`) occurs before Event 3-6 (start() emissions). Same timestamp indicates rapid sequential execution. |
| **ctx.job_id available and correct format** | ✓ PASS | Event 3 shows `ctx.job_id` = `"job_58f8635f-247e-4a74-a427-002ae1cc15b5"` (UUID format) |
| **ctx.javaAvailable() returns true** | ✓ PASS | Event 4 shows `value: true` |
| **ctx.requireJava() returns Java bridge** | ✓ PASS | Event 5 shows `success: true` (Java object is not null) |
| **params correctly passed** | ✓ PASS | Event 6 shows all parameters intact with correct types |
| **Return value captured as job result** | ✓ PASS | Event 7 (`job.completed`) contains the complete return object in `payload.result` |

**Overall Result**: ALL TESTS PASSED ✓

---

## Key Findings

### 1. Lifecycle Order
The job lifecycle executed in the correct order:
1. `job.started` (system event)
2. `init()` called (user code)
3. `start()` called (user code)
4. `job.completed` (system event with result)

All events have identical timestamps (`2026-01-21T06:08:20.654Z`), indicating execution completed within a single millisecond.

### 2. ctx Object Functionality
The `ctx` object provides:
- **ctx.job_id**: Available in both `init()` and `start()`, contains the UUID job identifier
- **ctx.javaAvailable()**: Returns boolean indicating Java runtime availability
- **ctx.requireJava()**: Returns the Frida Java bridge object when Java is available
- **ctx.emit()**: Successfully emits custom events with kind, payload, and level

### 3. Parameter Passing
Parameters are passed as a plain JavaScript object to `start(params, ctx)` with full type preservation:
- Strings remain strings
- Numbers remain numbers
- Nested objects maintain structure
- No serialization artifacts observed

### 4. Return Value Handling
For `oneshot` jobs:
- Return values are captured in the `job.completed` event
- Complex objects (with nested data) are fully serialized
- The result is accessible via the event stream

### 5. Event Timing
All events emitted during the job have the same timestamp, suggesting:
- The orchestrator buffers events during execution
- Events are flushed as a batch after job completion
- Event ordering is preserved despite identical timestamps

---

## Observations

1. **Job Execution Speed**: 265ms total execution time for a simple oneshot job demonstrates efficient orchestrator overhead.

2. **Event ID Format**: All events have UUID format event_ids, enabling precise event tracking and correlation.

3. **Target Persistence**: The job executed successfully on target `tgt_7a20e4fc-12f7-42c2-8e4d-4569053eeff6` without requiring re-instrumentation.

4. **Health Status**: Job health is `"unknown"` for completed oneshot jobs (expected, as health monitoring is for daemon jobs).

---

## Conclusions

### Status: COMPLETE

All validation criteria met. The ctx API provides:
- Reliable lifecycle hooks (`init`, `start`)
- Consistent job identification (`ctx.job_id`)
- Java runtime detection and access (`javaAvailable`, `requireJava`)
- Flexible parameter passing (complex objects supported)
- Event emission capability (`ctx.emit`)
- Result capture for oneshot jobs (via `job.completed` event)

The basic job infrastructure is functioning correctly and ready for more complex instrumentation tasks.

---

## Recommendations for Next Steps

1. **Test ctx.stdlib**: Explore the standard library utilities available via `ctx.stdlib.*`
2. **Test daemon jobs**: Validate long-running jobs with `ctx.heartbeat()` calls
3. **Test interactive jobs**: Verify bi-directional communication patterns
4. **Test error handling**: Intentionally trigger errors to observe failure modes
5. **Test hook lifecycle**: Verify Interceptor.attach hooks are properly installed and cleaned up

---

**Report Generated**: 2026-01-21T06:08:21Z
**Analyst**: Android Security Research Worker
**Phase**: 3.1 - Basic Job Validation
